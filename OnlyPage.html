<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Task Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Custom styles */
        .kanban-column {
            min-height: 300px;
            border-radius: 0.5rem;
            padding: 1rem;
            transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
        }
        .task {
            cursor: grab;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: flex;
            flex-direction: column; /* Stack content vertically */
            align-items: stretch; /* Stretch items */
            position: relative; /* For absolute positioning of buttons */
            padding-bottom: 2.5rem; /* Space for buttons at the bottom */
        }
        .task:active { cursor: grabbing; }
        .task.dragging { opacity: 0.5; border: 2px dashed #cbd5e1; }
        .drag-over { border: 2px dashed #2563eb; background-color: #eff6ff; }

        #message-box {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; color: white; border-radius: 0.375rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); z-index: 1000;
            display: none; font-family: 'Inter', sans-serif;
        }
        body { font-family: 'Inter', sans-serif; }

        /* Task details styling */
        .task-details {
            font-size: 0.8rem; /* Smaller text */
            color: #6b7280; /* gray-500 */
            margin-top: 0.5rem; /* space above details */
            display: flex;
            flex-direction: column; /* Stack due date and completed time */
            gap: 0.1rem;
        }
         .task-details span { /* Ensure details don't prevent dragging */
             pointer-events: none;
         }
        .task-due-date-display { /* Container for due date text and edit icon */
            display: flex;
            align-items: center;
            gap: 0.3rem;
            cursor: pointer; /* Indicate clickable */
        }
        .task-due-date-display:hover .edit-due-date-icon {
             opacity: 1;
        }
        .task-due-date.overdue {
            color: #ef4444; /* red-500 */
            font-weight: 600; /* semibold */
        }
        .edit-due-date-icon {
            font-size: 0.7rem;
            opacity: 0.5;
            transition: opacity 0.2s ease;
            pointer-events: all; /* Make icon clickable */
        }
        .edit-due-date-input {
             font-size: 0.8rem;
             padding: 0.1rem 0.2rem;
             border: 1px solid #d1d5db; /* gray-300 */
             border-radius: 0.25rem; /* rounded-sm */
             max-width: 150px; /* Prevent input from becoming too wide */
        }


        /* Buttons container at the bottom of the task */
        .task-buttons {
            position: absolute;
            bottom: 0.5rem; /* Position near the bottom */
            right: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }
        .task-button {
            background: none; border: none; cursor: pointer;
            font-size: 0.9rem; padding: 0.1rem 0.25rem;
            opacity: 0.6; transition: opacity 0.2s ease, color 0.2s ease;
            color: #6b7280; /* gray-500 */
        }
        .task:hover .task-button { opacity: 1; }
        .task-button:hover { color: #1f2937; /* gray-800 */ }
        .delete-task-btn:hover { color: #dc2626; /* red-600 */}
        .archive-task-btn:hover { color: #ca8a04; /* yellow-600 */}
        .unarchive-task-btn:hover { color: #2563eb; /* blue-600 */}

        .tasks-container { min-height: 50px; }
        #import-excel-input { display: none; }

        /* Archived column style */
        #archived-column { background-color: #e5e7eb; border-color: #d1d5db; } /* gray-200, gray-300 */
        #archived-column h2 { color: #4b5563; border-color: #9ca3af; } /* gray-600, gray-400 */
        #archived-column .task { background-color: #f3f4f6; } /* gray-100 */
        #archived-column .task .task-text { text-decoration: line-through; color: #6b7280; }

        /* Style for hidden column */
        #archived-column.hidden { display: none; }
        /* Hide elements using this class */
        .hidden { display: none !important; }

    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="container mx-auto max-w-7xl"> <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">My Kanban Board</h1>

        <div id="message-box"></div>

        <div class="mb-8 p-4 bg-white rounded-lg shadow space-y-4">
            <div>
                <h2 class="text-xl font-semibold mb-3 text-gray-700">Add New Task</h2>
                <div class="flex flex-col sm:flex-row gap-3 items-end"> <div class="flex-grow">
                        <label for="new-task-input" class="block text-sm font-medium text-gray-700 mb-1">Task Description</label>
                        <input type="text" id="new-task-input" placeholder="Enter task description..." class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                     <div class="shrink-0">
                         <label for="new-task-due-date" class="block text-sm font-medium text-gray-700 mb-1">Due Date (Optional)</label>
                        <input type="date" id="new-task-due-date" class="w-full sm:w-auto p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                     </div>
                    <button id="add-task-button" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition duration-200 ease-in-out shrink-0 self-end h-[42px]"> Add Task
                    </button>
                </div>
            </div>
             <div class="flex flex-col sm:flex-row gap-3 flex-wrap"> <button id="import-excel-button" class="w-full sm:w-auto bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-md transition duration-200 ease-in-out">
                    <i class="fas fa-file-import mr-2"></i>Import
                </button>
                 <button id="export-excel-button" class="w-full sm:w-auto bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md transition duration-200 ease-in-out">
                     <i class="fas fa-file-export mr-2"></i>Export
                </button>
                 <button id="toggle-archive-button" class="w-full sm:w-auto bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md transition duration-200 ease-in-out">
                     <i class="fas fa-eye mr-2"></i><span id="toggle-archive-text">Hide Archive</span>
                </button>
                <input type="file" id="import-excel-input" accept=".xlsx, .xls">
             </div>
        </div>

        <div id="kanban-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            <div id="todo-column" class="kanban-column bg-red-100 border border-red-200" data-column-id="todo">
                <h2 class="text-lg font-semibold mb-4 text-red-800 border-b-2 border-red-300 pb-2">To Do</h2>
                <div id="todo-tasks" class="tasks-container space-y-3"></div>
            </div>
            <div id="inprogress-column" class="kanban-column bg-yellow-100 border border-yellow-200" data-column-id="inprogress">
                <h2 class="text-lg font-semibold mb-4 text-yellow-800 border-b-2 border-yellow-300 pb-2">In Progress</h2>
                 <div id="inprogress-tasks" class="tasks-container space-y-3"></div>
            </div>
            <div id="done-column" class="kanban-column bg-green-100 border border-green-200" data-column-id="done">
                <h2 class="text-lg font-semibold mb-4 text-green-800 border-b-2 border-green-300 pb-2">Done ðŸŽ‰</h2>
                 <div id="done-tasks" class="tasks-container space-y-3"></div>
            </div>
             <div id="archived-column" class="kanban-column" data-column-id="archived"> <h2 class="text-lg font-semibold mb-4 border-b-2 pb-2">Archived ðŸ“¦</h2>
                 <div id="archived-tasks" class="tasks-container space-y-3"></div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const columns = document.querySelectorAll('.kanban-column');
        const addTaskButton = document.getElementById('add-task-button');
        const newTaskInput = document.getElementById('new-task-input');
        const newTaskDueDateInput = document.getElementById('new-task-due-date');
        const messageBox = document.getElementById('message-box');
        const exportButton = document.getElementById('export-excel-button');
        const importButton = document.getElementById('import-excel-button');
        const importInput = document.getElementById('import-excel-input');
        const toggleArchiveButton = document.getElementById('toggle-archive-button');
        const toggleArchiveText = document.getElementById('toggle-archive-text');
        const toggleArchiveIcon = toggleArchiveButton.querySelector('i');
        const todoTasksContainer = document.getElementById('todo-tasks');
        const inprogressTasksContainer = document.getElementById('inprogress-tasks');
        const doneTasksContainer = document.getElementById('done-tasks');
        const archivedTasksContainer = document.getElementById('archived-tasks');
        const archivedColumn = document.getElementById('archived-column');
        const kanbanGrid = document.getElementById('kanban-grid');

        const LOCAL_STORAGE_KEY = 'kanbanState_v2';
        const ARCHIVE_VISIBLE_KEY = 'kanbanArchiveVisible';

        let draggedTask = null;
        let isDirtySinceLastExport = false; // Track changes since last EXPORT

        // --- Mappings ---
        const statusToContainerMap = { 'to do': todoTasksContainer, 'in progress': inprogressTasksContainer, 'done': doneTasksContainer, 'archived': archivedTasksContainer };
        const columnIdToStatusMap = { 'todo-column': 'To Do', 'inprogress-column': 'In Progress', 'done-column': 'Done', 'archived-column': 'Archived' };

        // --- Utility Functions ---
        function showMessage(message, type = 'error') { /* ... (no change) ... */
             messageBox.textContent = message; messageBox.className = `fixed top-5 left-1/2 transform -translate-x-1/2 p-3 rounded-md shadow-lg text-white font-semibold ${type === 'error' ? 'bg-red-500' : 'bg-green-500'}`; messageBox.style.display = 'block'; setTimeout(() => { messageBox.style.display = 'none'; }, 3000);
        }
        function formatDisplayDate(dateString) { /* ... (no change) ... */
             if (!dateString) return ''; try { const date = new Date(dateString); if (dateString.length === 10) { const offset = date.getTimezoneOffset(); date.setMinutes(date.getMinutes() + offset); } return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }); } catch (e) { console.error("Error formatting date:", dateString, e); return dateString; }
        }
        function formatDisplayDateTime(timestampString) { /* ... (no change) ... */
             if (!timestampString) return ''; try { const date = new Date(timestampString); return date.toLocaleString(undefined, { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }); } catch (e) { console.error("Error formatting timestamp:", timestampString, e); return timestampString; }
        }
        function isOverdue(dueDateString) { /* ... (no change) ... */
             if (!dueDateString) return false; try { const today = new Date(); today.setHours(0, 0, 0, 0); const dateParts = dueDateString.split('-'); const dueDate = new Date(Date.UTC(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]))); return dueDate < today; } catch (e) { console.error("Error checking overdue status:", dueDateString, e); return false; }
        }
        function createTaskElement(text, id, dueDate = null, completionTime = null, isArchived = false) { /* ... (no change) ... */
            const taskDiv = document.createElement('div'); taskDiv.classList.add('task', 'bg-white', 'p-3', 'rounded-md', 'shadow', 'border', 'border-gray-200'); taskDiv.setAttribute('draggable', !isArchived); taskDiv.setAttribute('data-task-id', id); if (dueDate) taskDiv.setAttribute('data-due-date', dueDate); if (completionTime) taskDiv.setAttribute('data-completion-time', completionTime); const textSpan = document.createElement('span'); textSpan.classList.add('task-text', 'font-medium', 'text-gray-800'); textSpan.textContent = text; taskDiv.appendChild(textSpan); const detailsDiv = document.createElement('div'); detailsDiv.classList.add('task-details'); const dueDateContainer = document.createElement('div'); dueDateContainer.classList.add('task-due-date-container'); const dueDateDisplay = document.createElement('span'); dueDateDisplay.classList.add('task-due-date-display'); if (!dueDate) dueDateDisplay.classList.add('hidden'); dueDateDisplay.innerHTML = ` <span class="task-due-date-text"> <i class="far fa-calendar-alt mr-1"></i> Due: ${formatDisplayDate(dueDate)} </span> <i class="fas fa-pencil-alt edit-due-date-icon ml-1" title="Edit due date"></i> `; if (dueDate && !completionTime && !isArchived && isOverdue(dueDate)) { dueDateDisplay.querySelector('.task-due-date-text').classList.add('overdue'); dueDateDisplay.querySelector('.edit-due-date-icon').title = "Edit overdue date"; } dueDateDisplay.addEventListener('click', startDueDateEdit); dueDateContainer.appendChild(dueDateDisplay); const dueDateInput = document.createElement('input'); dueDateInput.type = 'date'; dueDateInput.classList.add('edit-due-date-input', 'hidden'); dueDateInput.value = dueDate || ''; dueDateInput.addEventListener('change', saveDueDateEdit); dueDateInput.addEventListener('blur', saveDueDateEdit); dueDateContainer.appendChild(dueDateInput); detailsDiv.appendChild(dueDateContainer); if (completionTime) { const completedSpan = document.createElement('span'); completedSpan.classList.add('task-completion-time'); completedSpan.innerHTML = `<i class="fas fa-check-circle mr-1 text-green-600"></i> Completed: ${formatDisplayDateTime(completionTime)}`; detailsDiv.appendChild(completedSpan); } if (detailsDiv.hasChildNodes()) { taskDiv.appendChild(detailsDiv); } const buttonsDiv = document.createElement('div'); buttonsDiv.classList.add('task-buttons'); if (isArchived) { const unarchiveBtn = document.createElement('button'); unarchiveBtn.classList.add('task-button', 'unarchive-task-btn'); unarchiveBtn.innerHTML = '<i class="fas fa-box-open"></i>'; unarchiveBtn.title = "Unarchive Task"; unarchiveBtn.onclick = handleUnarchiveTask; buttonsDiv.appendChild(unarchiveBtn); } else { const archiveBtn = document.createElement('button'); archiveBtn.classList.add('task-button', 'archive-task-btn'); archiveBtn.innerHTML = '<i class="fas fa-archive"></i>'; archiveBtn.title = "Archive Task"; archiveBtn.onclick = handleArchiveTask; buttonsDiv.appendChild(archiveBtn); } const deleteBtn = document.createElement('button'); deleteBtn.classList.add('task-button', 'delete-task-btn'); deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; deleteBtn.title = "Delete Task"; deleteBtn.onclick = handleDeleteTask; buttonsDiv.appendChild(deleteBtn); taskDiv.appendChild(buttonsDiv); if (!isArchived) { addTaskDragListeners(taskDiv); } return taskDiv;
        }
        function addTaskDragListeners(task) { /* ... (no change) ... */
             task.addEventListener('dragstart', handleDragStart); task.addEventListener('dragend', handleDragEnd);
        }

        // --- State Management ---
        function saveState() { /* ... (no change) ... */
             const state = { todo: [], inprogress: [], done: [], archived: [] }; const getTaskData = (task) => ({ id: task.dataset.taskId, text: task.querySelector('.task-text').textContent, dueDate: task.dataset.dueDate || null, completionTime: task.dataset.completionTime || null }); document.querySelectorAll('#todo-tasks .task').forEach(task => state.todo.push(getTaskData(task))); document.querySelectorAll('#inprogress-tasks .task').forEach(task => state.inprogress.push(getTaskData(task))); document.querySelectorAll('#done-tasks .task').forEach(task => state.done.push(getTaskData(task))); document.querySelectorAll('#archived-tasks .task').forEach(task => state.archived.push(getTaskData(task))); try { localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state)); isDirtySinceLastExport = true; console.log("Board state saved. Marked as dirty for export."); } catch (error) { console.error("Error saving state to Local Storage:", error); showMessage("Could not save board state locally.", "error"); }
        }
        function loadState() { /* ... (no change) ... */
             try { const savedState = localStorage.getItem(LOCAL_STORAGE_KEY); if (!savedState) { console.log("No saved state found."); return; } const state = JSON.parse(savedState); clearBoard(); const createTaskAndAppend = (taskData, container, isArchived = false) => { container.appendChild(createTaskElement(taskData.text, taskData.id, taskData.dueDate, taskData.completionTime, isArchived)); }; state.todo?.forEach(task => createTaskAndAppend(task, todoTasksContainer)); state.inprogress?.forEach(task => createTaskAndAppend(task, inprogressTasksContainer)); state.done?.forEach(task => createTaskAndAppend(task, doneTasksContainer)); state.archived?.forEach(task => createTaskAndAppend(task, archivedTasksContainer, true)); isDirtySinceLastExport = true; console.log("Board state loaded. Marked as dirty for export."); } catch (error) { console.error("Error loading state from Local Storage:", error); showMessage("Could not load previous board state.", "error"); localStorage.removeItem(LOCAL_STORAGE_KEY); }
        }
        function clearBoard() { /* ... (no change) ... */
             todoTasksContainer.innerHTML = ''; inprogressTasksContainer.innerHTML = ''; doneTasksContainer.innerHTML = ''; archivedTasksContainer.innerHTML = '';
        }

        // --- Archive Visibility ---
        function setArchiveVisibility(isVisible) { /* ... (no change) ... */
            if (!archivedColumn || !kanbanGrid || !toggleArchiveButton || !toggleArchiveText || !toggleArchiveIcon) return; if (isVisible) { archivedColumn.classList.remove('hidden'); kanbanGrid.classList.remove('lg:grid-cols-3'); kanbanGrid.classList.add('lg:grid-cols-4'); toggleArchiveText.textContent = "Hide Archive"; toggleArchiveIcon.classList.remove('fa-eye-slash'); toggleArchiveIcon.classList.add('fa-eye'); toggleArchiveButton.setAttribute('aria-pressed', 'false'); } else { archivedColumn.classList.add('hidden'); kanbanGrid.classList.remove('lg:grid-cols-4'); kanbanGrid.classList.add('lg:grid-cols-3'); toggleArchiveText.textContent = "Show Archive"; toggleArchiveIcon.classList.remove('fa-eye'); toggleArchiveIcon.classList.add('fa-eye-slash'); toggleArchiveButton.setAttribute('aria-pressed', 'true'); } try { localStorage.setItem(ARCHIVE_VISIBLE_KEY, isVisible.toString()); } catch (error) { console.error("Error saving archive visibility state:", error); }
        }
        function handleToggleArchive() { /* ... (no change) ... */
             const isCurrentlyVisible = !archivedColumn.classList.contains('hidden'); setArchiveVisibility(!isCurrentlyVisible);
        }
        function loadArchiveVisibilityPreference() { /* ... (no change) ... */
             try { const savedPref = localStorage.getItem(ARCHIVE_VISIBLE_KEY); const isVisible = savedPref === null ? true : (savedPref === 'true'); setArchiveVisibility(isVisible); } catch (error) { console.error("Error loading archive visibility state:", error); setArchiveVisibility(true); }
        }

        // --- Due Date Editing ---
        function startDueDateEdit(event) { /* ... (no change) ... */
             event.stopPropagation(); const displayContainer = event.currentTarget; const taskElement = displayContainer.closest('.task'); const inputElement = taskElement.querySelector('.edit-due-date-input'); if (!inputElement || !taskElement) return; displayContainer.classList.add('hidden'); inputElement.classList.remove('hidden'); inputElement.value = taskElement.dataset.dueDate || ''; inputElement.focus();
        }
        function saveDueDateEdit(event) { /* ... (no change) ... */
            const inputElement = event.target; const taskElement = inputElement.closest('.task'); const displayContainer = taskElement.querySelector('.task-due-date-display'); const displayTextElement = displayContainer?.querySelector('.task-due-date-text'); if (!taskElement || !displayContainer || !displayTextElement) return; const newDueDate = inputElement.value; if (newDueDate) { taskElement.setAttribute('data-due-date', newDueDate); } else { taskElement.removeAttribute('data-due-date'); } if (newDueDate) { displayTextElement.innerHTML = `<i class="far fa-calendar-alt mr-1"></i> Due: ${formatDisplayDate(newDueDate)}`; const isArchived = taskElement.closest('#archived-column') !== null; const completionTime = taskElement.dataset.completionTime; if (!completionTime && !isArchived && isOverdue(newDueDate)) { displayTextElement.classList.add('overdue'); displayContainer.querySelector('.edit-due-date-icon').title = "Edit overdue date"; } else { displayTextElement.classList.remove('overdue'); displayContainer.querySelector('.edit-due-date-icon').title = "Edit due date"; } displayContainer.classList.remove('hidden'); } else { displayContainer.classList.add('hidden'); displayTextElement.classList.remove('overdue'); displayTextElement.innerHTML = ''; } inputElement.classList.add('hidden'); saveState();
        }


        // --- Event Handlers ---
        function handleDragStart(event) { /* ... (no change) ... */
             if (!event.target.getAttribute('draggable') || event.target.getAttribute('draggable') === 'false') { event.preventDefault(); return; } if (event.target.classList.contains('task')) { draggedTask = event.target; event.dataTransfer.setData('text/plain', draggedTask.dataset.taskId); setTimeout(() => draggedTask.classList.add('dragging'), 0); } else { event.preventDefault(); }
        }
        function handleDragEnd() { /* ... (no change) ... */
             if (draggedTask && draggedTask.classList.contains('dragging')) { draggedTask.classList.remove('dragging'); } draggedTask = null;
        }
        function handleDragOver(event) { /* ... (no change) ... */
             event.preventDefault(); if (event.currentTarget.id === 'archived-column') { event.dataTransfer.dropEffect = 'none'; return; } if (event.currentTarget.classList.contains('kanban-column')) { event.currentTarget.classList.add('drag-over'); event.dataTransfer.dropEffect = 'move'; }
        }
        function handleDragLeave(event) { /* ... (no change) ... */
             if (event.currentTarget.classList.contains('kanban-column')) { event.currentTarget.classList.remove('drag-over'); }
        }
        function handleDrop(event) { /* ... (no change) ... */
            event.preventDefault(); const dropZone = event.currentTarget; if (!dropZone || dropZone.id === 'archived-column') { if (draggedTask) draggedTask.classList.remove('dragging'); draggedTask = null; columns.forEach(col => col.classList.remove('drag-over')); return; } if (dropZone.classList.contains('kanban-column') && draggedTask) { dropZone.classList.remove('drag-over'); const tasksContainer = dropZone.querySelector('.tasks-container'); if (tasksContainer) { const originalContainer = draggedTask.parentElement; const originalColumnId = originalContainer?.closest('.kanban-column')?.id; const newColumnId = dropZone.id; tasksContainer.appendChild(draggedTask); const completionTimeSpan = draggedTask.querySelector('.task-completion-time'); const dueDateDisplay = draggedTask.querySelector('.task-due-date-display'); const dueDateText = dueDateDisplay?.querySelector('.task-due-date-text'); if (newColumnId === 'done-column' && originalColumnId !== 'done-column') { const now = new Date().toISOString(); draggedTask.setAttribute('data-completion-time', now); let detailsDiv = draggedTask.querySelector('.task-details'); if (!detailsDiv) { detailsDiv = document.createElement('div'); detailsDiv.classList.add('task-details'); const buttonsDiv = draggedTask.querySelector('.task-buttons'); if (buttonsDiv) { draggedTask.insertBefore(detailsDiv, buttonsDiv); } else { draggedTask.appendChild(detailsDiv); } } let existingCompletionSpan = detailsDiv.querySelector('.task-completion-time'); if (existingCompletionSpan) { existingCompletionSpan.innerHTML = `<i class="fas fa-check-circle mr-1 text-green-600"></i> Completed: ${formatDisplayDateTime(now)}`; } else { const newSpan = document.createElement('span'); newSpan.classList.add('task-completion-time'); newSpan.innerHTML = `<i class="fas fa-check-circle mr-1 text-green-600"></i> Completed: ${formatDisplayDateTime(now)}`; detailsDiv.appendChild(newSpan); } if (dueDateText) { dueDateText.classList.remove('overdue'); } if (typeof confetti === 'function') { confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }, zIndex: 1050 }); } } else if (originalColumnId === 'done-column' && newColumnId !== 'done-column') { draggedTask.removeAttribute('data-completion-time'); const existingCompletionSpan = draggedTask.querySelector('.task-completion-time'); if (existingCompletionSpan) { existingCompletionSpan.remove(); } if (dueDateText && isOverdue(draggedTask.dataset.dueDate)) { dueDateText.classList.add('overdue'); } } saveState(); } else { console.error("Could not find tasks container in drop zone:", dropZone); } } columns.forEach(col => col.classList.remove('drag-over'));
        }
        function handleAddTask() { /* ... (no change) ... */
             const taskText = newTaskInput.value.trim(); const dueDate = newTaskDueDateInput.value; if (taskText === '') { showMessage('Task description cannot be empty!', 'error'); return; } const taskId = `task-${Date.now()}`; const newTaskElement = createTaskElement(taskText, taskId, dueDate || null); if (todoTasksContainer) { todoTasksContainer.appendChild(newTaskElement); newTaskInput.value = ''; newTaskDueDateInput.value = ''; showMessage('Task added successfully!', 'success'); saveState(); } else { console.error("Could not find 'To Do' tasks container."); showMessage('Error adding task.', 'error'); }
        }
        function handleDeleteTask(event) { /* ... (no change) ... */
             const taskElement = event.target.closest('.task'); if (taskElement) { taskElement.remove(); showMessage('Task deleted.', 'success'); saveState(); }
        }
        function handleArchiveTask(event) { /* ... (no change) ... */
             const taskElement = event.target.closest('.task'); if (taskElement && archivedTasksContainer) { taskElement.setAttribute('draggable', 'false'); taskElement.removeEventListener('dragstart', handleDragStart); taskElement.removeEventListener('dragend', handleDragEnd); taskElement.classList.remove('dragging'); const archiveBtn = taskElement.querySelector('.archive-task-btn'); if (archiveBtn) { const unarchiveBtn = document.createElement('button'); unarchiveBtn.classList.add('task-button', 'unarchive-task-btn'); unarchiveBtn.innerHTML = '<i class="fas fa-box-open"></i>'; unarchiveBtn.title = "Unarchive Task"; unarchiveBtn.onclick = handleUnarchiveTask; archiveBtn.replaceWith(unarchiveBtn); } taskElement.querySelector('.task-text')?.classList.add('line-through', 'text-gray-500'); taskElement.style.backgroundColor = '#f3f4f6'; archivedTasksContainer.appendChild(taskElement); showMessage('Task archived.', 'success'); saveState(); }
        }
        function handleUnarchiveTask(event) { /* ... (no change) ... */
             const taskElement = event.target.closest('.task'); if (taskElement && todoTasksContainer) { taskElement.setAttribute('draggable', 'true'); addTaskDragListeners(taskElement); const unarchiveBtn = taskElement.querySelector('.unarchive-task-btn'); if (unarchiveBtn) { const archiveBtn = document.createElement('button'); archiveBtn.classList.add('task-button', 'archive-task-btn'); archiveBtn.innerHTML = '<i class="fas fa-archive"></i>'; archiveBtn.title = "Archive Task"; archiveBtn.onclick = handleArchiveTask; unarchiveBtn.replaceWith(archiveBtn); } taskElement.querySelector('.task-text')?.classList.remove('line-through', 'text-gray-500'); taskElement.style.backgroundColor = ''; todoTasksContainer.appendChild(taskElement); showMessage('Task unarchived to To Do.', 'success'); saveState(); }
        }
        function exportToExcel() { /* ... (no change) ... */
             if (typeof XLSX === 'undefined') { showMessage('Excel library not loaded.', 'error'); return; } try { const tasksData = []; document.querySelectorAll('.kanban-column').forEach(column => { const status = columnIdToStatusMap[column.id] || 'Unknown'; column.querySelectorAll('.task').forEach(task => { const taskTextElement = task.querySelector('.task-text'); tasksData.push({ Task: taskTextElement ? taskTextElement.textContent.trim() : '', Status: status, 'Due Date': task.dataset.dueDate || '', 'Completion Time': task.dataset.completionTime ? formatDisplayDateTime(task.dataset.completionTime) : '' }); }); }); if (tasksData.length === 0) { showMessage('No tasks to export.', 'error'); isDirtySinceLastExport = false; return; } const headers = ["Task", "Status", "Due Date", "Completion Time"]; const worksheet = XLSX.utils.json_to_sheet(tasksData, { header: headers }); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "Tasks"); worksheet['!cols'] = [{ wch: 50 }, { wch: 15 }, { wch: 15 }, { wch: 25 }]; const today = new Date(); const dateString = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`; const filename = `kanban_tasks_${dateString}.xlsx`; XLSX.writeFile(workbook, filename); isDirtySinceLastExport = false; showMessage('Tasks exported successfully!', 'success'); console.log("Export successful. Marked as clean."); } catch (error) { console.error("Error exporting to Excel:", error); showMessage('An error occurred during export.', 'error'); }
        }

        /**
         * Handles importing tasks from an Excel file.
         * Includes refined date parsing logic.
         */
        function handleImportExcel(event) {
             const file = event.target.files[0]; if (!file) { return; }
             if (typeof XLSX === 'undefined' || typeof FileReader === 'undefined') {
                 showMessage('Required browser features not available.', 'error'); return;
             }
             const reader = new FileReader();
             reader.onload = (e) => {
                 try {
                     const data = e.target.result;
                     // Use cellDates:true as first attempt, but use raw:true in sheet_to_json
                     // to handle cases where cellDates fails or isn't applicable.
                     const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                     const firstSheetName = workbook.SheetNames[0];
                     const worksheet = workbook.Sheets[firstSheetName];
                     // Use raw: true to get underlying values (numbers for dates)
                     const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: true });

                     clearBoard();
                     let tasksImported = 0;
                     let tasksSkipped = 0;

                     jsonData.forEach((row, index) => {
                         const normalizedRow = {};
                         for (const key in row) { // Normalize keys
                             normalizedRow[key.toLowerCase().replace(/\s+/g, '')] = row[key];
                         }

                         const taskText = normalizedRow['task']?.toString().trim();
                         const statusText = normalizedRow['status']?.toString().trim().toLowerCase();
                         const rawDueDate = normalizedRow['duedate']; // Get raw value
                         let dueDate = null; // Final YYYY-MM-DD date string
                         let completionTime = normalizedRow['completiontime'] || null; // Keep existing logic for completion time

                         // --- Due Date Parsing Logic ---
                         if (rawDueDate !== undefined && rawDueDate !== null && rawDueDate !== '') {
                             if (typeof rawDueDate === 'number') {
                                 // Attempt to parse Excel serial date number
                                 try {
                                     // Check if it's within a reasonable range for Excel dates
                                     // (Excel dates are typically > 1, avoiding epoch 0 issues)
                                     if (rawDueDate > 0) {
                                         const parsed = XLSX.SSF.parse_date_code(rawDueDate);
                                         if (parsed && parsed.y && parsed.m && parsed.d) {
                                             const year = parsed.y;
                                             const month = String(parsed.m).padStart(2, '0'); // m is 1-based
                                             const day = String(parsed.d).padStart(2, '0');
                                             dueDate = `${year}-${month}-${day}`;
                                             console.log(`Parsed Excel date number ${rawDueDate} to ${dueDate} for row ${index + 1}`);
                                         } else {
                                              console.warn(`Could not parse Excel date number "${rawDueDate}" on row ${index + 1}.`);
                                         }
                                     } else {
                                         console.warn(`Excel date number "${rawDueDate}" out of expected range on row ${index + 1}.`);
                                     }
                                 } catch (e) {
                                      console.warn(`Error parsing Excel date number "${rawDueDate}" on row ${index + 1}:`, e);
                                 }
                             } else if (typeof rawDueDate === 'string') {
                                 const dateString = rawDueDate.trim();
                                 // Check if it looks like YYYY-MM-DD
                                 if (/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                                     const parts = dateString.split('-');
                                     const month = parseInt(parts[1], 10);
                                     const day = parseInt(parts[2], 10);
                                     if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                                          dueDate = dateString;
                                          console.log(`Using date string ${dateString} as is for row ${index + 1}.`);
                                     } else {
                                          console.warn(`Invalid date string format "${dateString}" on row ${index + 1}.`);
                                     }
                                 } else {
                                      // Last resort: try new Date() parsing for other string formats
                                      try {
                                          const parsedDate = new Date(dateString);
                                          // Check if parsing was successful and it's not epoch 0
                                          if (!isNaN(parsedDate.getTime()) && parsedDate.getTime() !== 0) {
                                              // Format to YYYY-MM-DD (extract parts to avoid timezone issues)
                                              const year = parsedDate.getFullYear();
                                              const month = String(parsedDate.getMonth() + 1).padStart(2, '0'); // getMonth is 0-based
                                              const day = String(parsedDate.getDate()).padStart(2, '0');
                                              dueDate = `${year}-${month}-${day}`;
                                              console.log(`Parsed date string "${dateString}" via new Date() to ${dueDate} for row ${index + 1}`);
                                          } else {
                                              console.warn(`Could not parse date string "${dateString}" via new Date() on row ${index + 1}.`);
                                          }
                                      } catch (e) {
                                          console.warn(`Error parsing date string "${dateString}" via new Date() on row ${index + 1}:`, e);
                                      }
                                 }
                             }
                             // Note: instanceof Date check removed as raw:true makes it less likely
                         }
                         // --- End Due Date Parsing ---


                         // --- Completion Time Parsing (existing logic) ---
                         if (completionTime) {
                             try {
                                 const parsedTime = new Date(completionTime);
                                 if (!isNaN(parsedTime.getTime()) && parsedTime.getTime() !== 0) {
                                     completionTime = parsedTime.toISOString(); // Store as ISO string
                                 } else {
                                     console.warn(`Could not parse Completion Time "${completionTime}" on row ${index + 1}. Ignoring.`);
                                     completionTime = null;
                                 }
                             } catch {
                                 console.warn(`Error processing Completion Time "${completionTime}" on row ${index + 1}. Ignoring.`);
                                 completionTime = null;
                             }
                         }
                         // --- End Completion Time Parsing ---


                         if (!taskText || !statusText) {
                             console.warn(`Skipping row ${index + 1}: Missing 'Task' or 'Status'.`);
                             tasksSkipped++; return;
                         }

                         const targetContainer = statusToContainerMap[statusText];
                         const isArchived = (statusText === 'archived');

                         if (targetContainer) {
                             const taskId = `imported-task-${Date.now()}-${index}`;
                             const taskElement = createTaskElement(taskText, taskId, dueDate, completionTime, isArchived);
                             targetContainer.appendChild(taskElement);
                             tasksImported++;
                         } else {
                             console.warn(`Skipping row ${index + 1}: Unknown status "${statusText}". Task "${taskText}" placed in 'To Do'.`);
                             const taskId = `imported-task-${Date.now()}-${index}`;
                             const taskElement = createTaskElement(taskText, taskId, dueDate, completionTime, false);
                             todoTasksContainer.appendChild(taskElement);
                             tasksSkipped++;
                         }
                     });

                     saveState(); // Save the imported state (marks as dirty)

                     if (tasksImported > 0) { showMessage(`Successfully imported ${tasksImported} tasks. ${tasksSkipped > 0 ? `${tasksSkipped} rows skipped (check console).` : ''}`, 'success'); }
                     else { showMessage(`Import failed or file empty. ${tasksSkipped > 0 ? `${tasksSkipped} rows skipped (check console).` : ''}`, 'error'); }

                 } catch (error) {
                     console.error("Error processing Excel file:", error);
                     showMessage('Error reading/processing Excel file. Check format and console.', 'error');
                 } finally {
                     importInput.value = ''; // Reset file input
                 }
             };
             reader.onerror = (error) => {
                 console.error("Error reading file:", error);
                 showMessage('Could not read the selected file.', 'error');
                 importInput.value = '';
             };
             reader.readAsArrayBuffer(file);
        }

        function handleBeforeUnload(event) { /* ... (no change) ... */
             if (isDirtySinceLastExport) { const message = "You have changes that haven't been exported to Excel. Are you sure you want to leave?"; event.preventDefault(); event.returnValue = message; return message; }
        }


        // --- Event Listeners Initialization ---
        columns.forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('dragleave', handleDragLeave);
            column.addEventListener('drop', handleDrop);
        });
        addTaskButton.addEventListener('click', handleAddTask);
        exportButton.addEventListener('click', exportToExcel);
        importButton.addEventListener('click', () => importInput.click());
        importInput.addEventListener('change', handleImportExcel);
        toggleArchiveButton.addEventListener('click', handleToggleArchive);
        newTaskInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { event.preventDefault(); handleAddTask(); } });
        window.addEventListener('beforeunload', handleBeforeUnload);

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadArchiveVisibilityPreference();
            loadState();
            if (typeof confetti !== 'function') console.warn("Confetti library not loaded!");
            if (typeof XLSX === 'undefined') console.warn("SheetJS XLSX library not loaded!");
        });

    </script>

</body>
</html>
